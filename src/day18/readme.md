1) Вам дан числовой массив произвольного размера. Посчитайте сумму чисел в этом массиве не используя циклы 
(необходимо использовать рекурсивные вызовы). Использовать статическое поле для хранения суммы не рекомендуется, 
такое решение нельзя назвать полноценно рекурсивным.
Пример:
int[] numbers = {1, 10, 1241, 50402, -50, 249, 10215, 665, 2295, 7, 311};
System.out.println(recursiveSum(...)); // 65346
*recursiveSum(...) - это ваш рекурсивный метод, который вернет сумму чисел в массиве numbers.

2) Создайте рекурсивный метод, который принимает на вход единственный аргумент - число, и
возвращает количество цифр 7 в этом числе. Циклы использовать запрещено, можно использовать
только рекурсивные вызовы. Использовать статическое поле для хранения количества цифр
не рекомендуется, такое решение нельзя назвать полноценно рекурсивным.
Пример:
System.out.println(count7(717771237)); // 5

3) Вам необходимо создать двоичное дерево поиска, изображенное на картинке выше.
Для этого создайте класс “Узел” (англ. Node), объекты которого будут содержать само значение узла
и поля-ссылки на два других узла (левый и правый потомки).
Затем, создайте корневой (англ. root) узел (со значением 20).
После этого, необходимо реализовать метод, который будет добавлять новые узлы в ваше дерево.
Этот метод должен принимать в качестве аргументов добавляемое значение и ссылку на корень дерева.
Проходясь по дереву, он должен вставлять новый узел в правильное место дерева.
Когда двоичное дерево, изображенное выше, будет создано, необходимо используя рекурсию вывести в
консоль все числа из этого двоичного дерева поиска в отсортированном виде. Ваше рекурсивное решение
должно работать для любого корректного двоичного дерева поиска. Этот алгоритм называется “обход в
глубину” (иногда называют “поиск в глубину”).
Ваш рекурсивный метод (пусть он будет называться dfs) должен в качестве единственного аргумента
принимать ссылку на корень дерева (root).
Вызов: dfs(root);
Вывод в консоль: 5 8 11 14 15 16 18 20 22 23 24 27 150
